import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { getFrameConfig } from '../config/frameConfigs.js';
import Testframe1 from '../assets/Testframe1.png';
import Testframe2 from '../assets/Testframe2.png';
import Testframe3 from '../assets/Testframe3.png';

export default function EditPhoto() {
  const navigate = useNavigate();
  const [photos, setPhotos] = useState([]);
  const [frameConfig, setFrameConfig] = useState(null);
  const [frameImage, setFrameImage] = useState(null);
  const [selectedFrame, setSelectedFrame] = useState('Testframe1'); // Add selected frame state
  const [activeToggle, setActiveToggle] = useState('filter');
  const [selectedPhoto, setSelectedPhoto] = useState(0);
  const [draggedPhoto, setDraggedPhoto] = useState(null);
  const [dragOverSlot, setDragOverSlot] = useState(null);
  const [photoPositions, setPhotoPositions] = useState({}); // Store photo positions for fine-tuning
  const [debugMode, setDebugMode] = useState(false); // Debug mode toggle
  const [configReloadKey, setConfigReloadKey] = useState(0); // Force config reload
  const [isReloading, setIsReloading] = useState(false); // Loading state for reload
  const [photoTransforms, setPhotoTransforms] = useState({}); // Store zoom and pan for each photo
  const [selectedPhotoForEdit, setSelectedPhotoForEdit] = useState(null); // Which photo is being edited
  const [isDraggingPhoto, setIsDraggingPhoto] = useState(false); // Track if dragging for pan
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 }); // Drag start position
  const [isSaving, setIsSaving] = useState(false); // Loading state for save

  // Frame image mapping
  const getFrameImage = (frameId) => {
    const frameMap = {
      'Testframe1': Testframe1,
      'Testframe2': Testframe2,
      'Testframe3': Testframe3
    };
    return frameMap[frameId] || Testframe1;
  };

  // Load photos and frame config on mount
  useEffect(() => {
    console.log('üîÑ EditPhoto component mounting...');
    
    // Load photos from localStorage
    const savedPhotos = localStorage.getItem('capturedPhotos');
    console.log('üì¶ Raw savedPhotos from localStorage:', savedPhotos);
    
    if (savedPhotos) {
      try {
        const parsedPhotos = JSON.parse(savedPhotos);
        console.log('üì∏ Parsed photos array:', parsedPhotos);
        console.log('üìä Number of photos:', parsedPhotos.length);
        
        setPhotos(parsedPhotos);
        
        // Initialize photo positions with better defaults for portrait photos
        const positions = {};
        const transforms = {};
        parsedPhotos.forEach((_, index) => {
          positions[index] = 'center center'; // Centered positioning
          transforms[index] = {
            scale: 1, // Will be calculated to auto-fill
            translateX: 0,
            translateY: 0,
            autoFillScale: 1 // Store the minimum scale to fill slot
          };
        });
        setPhotoPositions(positions);
        setPhotoTransforms(transforms);
        
        console.log('‚úÖ Loaded photos:', parsedPhotos.length);
      } catch (error) {
        console.error('‚ùå Error parsing photos:', error);
      }
    } else {
      console.log('‚ö†Ô∏è No saved photos found in localStorage');
    }

    // Load selected frame from localStorage
    const frameFromStorage = localStorage.getItem('selectedFrame') || 'Testframe1';
    console.log('üñºÔ∏è Frame from localStorage:', frameFromStorage);
    setSelectedFrame(frameFromStorage);
    console.log('üñºÔ∏è Loading frame:', frameFromStorage);
    
    const config = getFrameConfig(frameFromStorage);
    console.log('‚öôÔ∏è Frame config result:', config);
    
    if (config) {
      setFrameConfig(config);
      setFrameImage(getFrameImage(frameFromStorage));
      console.log('‚úÖ Frame config loaded:', config);
    } else {
      console.error('‚ùå Failed to load frame config for:', frameFromStorage);
    }
  }, []);

  // Initialize auto-fill scale when frameConfig is loaded
  useEffect(() => {
    if (frameConfig && photos.length > 0) {
      console.log('üéØ Auto-fitting photos to slots...');
      photos.forEach((_, index) => {
        const autoScale = calculateAutoFillScale(index);
        console.log(`üì∏ Photo ${index + 1}: Auto-fit scale = ${autoScale.toFixed(2)}x`);
        initializePhotoScale(index);
      });
    }
  }, [frameConfig, photos.length]);

  // Handle drag start
  const handleDragStart = (e, photoIndex, slotIndex) => {
    setDraggedPhoto({ photoIndex, slotIndex });
    e.dataTransfer.effectAllowed = 'move';
  };

  // Handle drag over
  const handleDragOver = (e, slotIndex) => {
    e.preventDefault();
    setDragOverSlot(slotIndex);
    e.dataTransfer.dropEffect = 'move';
  };

  // Handle drag leave
  const handleDragLeave = () => {
    setDragOverSlot(null);
  };

  // Handle drop
  const handleDrop = (e, targetSlotIndex) => {
    e.preventDefault();
    setDragOverSlot(null);
    
    if (!draggedPhoto) return;
    
    const { photoIndex: draggedPhotoIndex, slotIndex: sourceSlotIndex } = draggedPhoto;
    
    if (sourceSlotIndex === targetSlotIndex) {
      setDraggedPhoto(null);
      return;
    }

    // Create new photos array with swapped positions
    const newPhotos = [...photos];
    const newPhotoPositions = { ...photoPositions };
    
    // Swap photos
    const temp = newPhotos[sourceSlotIndex];
    newPhotos[sourceSlotIndex] = newPhotos[targetSlotIndex];
    newPhotos[targetSlotIndex] = temp;
    
    // Swap photo positions
    const tempPos = newPhotoPositions[sourceSlotIndex];
    newPhotoPositions[sourceSlotIndex] = newPhotoPositions[targetSlotIndex];
    newPhotoPositions[targetSlotIndex] = tempPos;
    
    setPhotos(newPhotos);
    setPhotoPositions(newPhotoPositions);
    localStorage.setItem('capturedPhotos', JSON.stringify(newPhotos));
    setDraggedPhoto(null);
    
    // Re-initialize auto-fit for swapped photos
    if (frameConfig) {
      setTimeout(() => {
        initializePhotoScale(sourceSlotIndex);
        initializePhotoScale(targetSlotIndex);
      }, 100);
    }
    
    console.log(`üîÑ Swapped photo from slot ${sourceSlotIndex} to slot ${targetSlotIndex}`);
  };

  // Calculate auto-fit scale untuk fit vertical height (ujung atas-bawah foto terlihat)
  const calculateAutoFillScale = (slotIndex) => {
    if (!frameConfig || !frameConfig.slots[slotIndex]) return 1;
    
    const slot = frameConfig.slots[slotIndex];
    
    // Untuk foto landscape (4:3) dalam slot portrait:
    // Kita ingin foto fit berdasarkan HEIGHT agar seluruh tinggi foto terlihat
    
    // objectFit: contain akan otomatis fit foto dalam slot
    // Kita perlu scale tambahan agar foto mengisi slot height dengan optimal
    
    // Simple approach: scale berdasarkan aspect ratio difference
    const slotAspectRatio = slot.width / slot.height; // biasanya < 1 (portrait)
    const photoAspectRatio = 4 / 3; // 1.33 (landscape)
    
    // Jika foto landscape masuk slot portrait:
    // Foto akan fit by height (atas-bawah pas), ada space kiri-kanan
    // Scale factor untuk mengoptimalkan tinggi
    const heightFitScale = 1.4; // Base scale untuk height fit
    
    // Adjustment berdasarkan ukuran slot
    const slotSizeAdjustment = 1 / slot.height; // Semakin kecil slot, semakin besar scale
    const finalScale = heightFitScale + (slotSizeAdjustment * 0.3);
    
    // Clamp antara 1.2x - 2.2x untuk range yang reasonable
    const clampedScale = Math.max(1.2, Math.min(2.2, finalScale));
    
    console.log(`üìè Slot ${slotIndex + 1}: Vertical-fit scale = ${clampedScale.toFixed(2)}x (slot: ${(slot.width*100).toFixed(0)}%√ó${(slot.height*100).toFixed(0)}%)`);
    
    return clampedScale;
  };

  // Initialize auto-fit scale for a photo
  const initializePhotoScale = (photoIndex) => {
    const autoFitScale = calculateAutoFillScale(photoIndex);
    console.log(`üîß Initializing photo ${photoIndex + 1} with auto-fit scale: ${autoFitScale.toFixed(2)}x`);
    
    setPhotoTransforms(prev => ({
      ...prev,
      [photoIndex]: {
        scale: autoFitScale,
        translateX: 0,
        translateY: 0,
        autoFillScale: autoFitScale
      }
    }));
  };

  // Fungsi untuk menghitung ukuran slot dalam pixel
  const calculateSlotDimensions = (frameConfig, slotIndex) => {
    const FRAME_WIDTH = 350; // px - ukuran frame di preview
    const FRAME_HEIGHT = 525; // px - aspect ratio 2:3
    
    const slot = frameConfig.slots[slotIndex];
    if (!slot) return null;
    
    return {
      left: slot.left * FRAME_WIDTH,      // px dari kiri
      top: slot.top * FRAME_HEIGHT,       // px dari atas  
      width: slot.width * FRAME_WIDTH,    // lebar slot dalam px
      height: slot.height * FRAME_HEIGHT, // tinggi slot dalam px
      aspectRatio: slot.width / slot.height // rasio slot
    };
  };

  // Fungsi untuk menghitung style photo viewport (preserving full image)
  const calculatePhotoCropStyle = (frameConfig, slotIndex) => {
    const slotDimensions = calculateSlotDimensions(frameConfig, slotIndex);
    if (!slotDimensions) return {};
    
    const transform = photoTransforms[slotIndex] || { scale: 1, translateX: 0, translateY: 0 };
    
    return {
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      objectFit: 'contain', // Preserve entire image, no permanent cropping
      objectPosition: 'center center',
      transform: `scale(${transform.scale}) translate(${transform.translateX}px, ${transform.translateY}px)`,
      transformOrigin: 'center center',
      transition: 'transform 0.2s ease'
    };
  };

  // Fungsi untuk reload frame config secara live  
  const reloadFrameConfig = () => {
    if (isReloading) return; // Prevent multiple calls
    
    setIsReloading(true);
    
    try {
      // Get current selected frame
      const selectedFrame = localStorage.getItem('selectedFrame') || 'Testframe1';
      console.log('üîÑ Attempting to reload config for:', selectedFrame);
      
      // Force component re-render with fresh import
      const timestamp = Date.now();
      
      // Use dynamic import with cache busting
      import(`../config/frameConfigs.js?t=${timestamp}`)
        .then(module => {
          console.log('üì¶ Module reloaded:', module);
          const newConfig = module.getFrameConfig(selectedFrame);
          if (newConfig) {
            setFrameConfig(newConfig);
            setConfigReloadKey(prev => prev + 1);
            console.log('‚úÖ Frame config reloaded successfully:', newConfig);
            
            // Re-apply auto-fit after config reload
            setTimeout(() => {
              photos.forEach((_, index) => {
                initializePhotoScale(index);
              });
            }, 200);
          } else {
            console.warn('‚ö†Ô∏è No config found for frame:', selectedFrame);
          }
        })
        .catch(error => {
          console.error('‚ùå Failed to reload module:', error);
          // Fallback: use existing getFrameConfig
          const fallbackConfig = getFrameConfig(selectedFrame);
          if (fallbackConfig) {
            setFrameConfig(fallbackConfig);
            setConfigReloadKey(prev => prev + 1);
            console.log('‚ö° Using fallback config reload:', fallbackConfig);
            
            // Re-apply auto-fit after fallback config
            setTimeout(() => {
              photos.forEach((_, index) => {
                initializePhotoScale(index);
              });
            }, 200);
          }
        })
        .finally(() => {
          setIsReloading(false);
        });
        
    } catch (error) {
      console.error('‚ùå Failed to reload frame config:', error);
      setIsReloading(false);
    }
  };

  // Handle photo zoom (dengan edge-to-edge boundaries)
  const handlePhotoZoom = (photoIndex, delta) => {
    setPhotoTransforms(prev => {
      const current = prev[photoIndex] || { scale: 1, translateX: 0, translateY: 0, autoFillScale: 1 };
      const autoFillScale = current.autoFillScale || calculateAutoFillScale(photoIndex);
      
      // Calculate minimum scale untuk edge-to-edge coverage
      const slot = frameConfig?.slots[photoIndex];
      if (!slot) return prev;
      
      const photoAspectRatio = 4 / 3;
      const slotAspectRatio = slot.width / slot.height;
      
      // Minimum scale agar foto edge bertemu slot edge (no gaps)
      let minScaleForCoverage;
      
      if (photoAspectRatio > slotAspectRatio) {
        // Foto landscape, slot portrait ‚Üí fit by height untuk full coverage
        minScaleForCoverage = 1 / (photoAspectRatio / slotAspectRatio);
      } else {
        // Foto portrait, slot landscape ‚Üí fit by width untuk full coverage  
        minScaleForCoverage = slotAspectRatio / photoAspectRatio;
      }
      
      // Apply reasonable bounds
      const absoluteMinScale = Math.max(0.8, minScaleForCoverage);
      const maxScale = 4;
      
      const newScale = Math.max(absoluteMinScale, Math.min(maxScale, current.scale + delta * 0.1));
      
      // Auto-adjust pan untuk maintain edge-to-edge setelah zoom
      const adjustedTransform = adjustPanForEdgeBoundaries(current, newScale, photoIndex);
      
      console.log(`üîç Photo ${photoIndex + 1}: Zoom ${delta > 0 ? 'IN' : 'OUT'} to ${newScale.toFixed(2)}x (min: ${absoluteMinScale.toFixed(2)}x for edge coverage)`);
      
      return {
        ...prev,
        [photoIndex]: {
          ...adjustedTransform,
          scale: newScale,
          autoFillScale: autoFillScale
        }
      };
    });
  };

  // Helper function untuk adjust pan berdasarkan edge boundaries
  const adjustPanForEdgeBoundaries = (current, newScale, photoIndex) => {
    const slot = frameConfig?.slots[photoIndex];
    if (!slot) return current;
    
    const photoAspectRatio = 4 / 3;
    const slotAspectRatio = slot.width / slot.height;
    
    // Calculate foto dimensions setelah scale
    let photoWidthInSlot, photoHeightInSlot;
    
    if (photoAspectRatio > slotAspectRatio) {
      photoWidthInSlot = 100;
      photoHeightInSlot = (100 / photoAspectRatio) * slotAspectRatio;
    } else {
      photoHeightInSlot = 100;
      photoWidthInSlot = (100 * photoAspectRatio) / slotAspectRatio;
    }
    
    const scaledPhotoWidth = photoWidthInSlot * newScale;
    const scaledPhotoHeight = photoHeightInSlot * newScale;
    
    // Calculate new max translate
    const maxTranslateXPx = Math.max(0, (scaledPhotoWidth - 100) / 2) * 3.5;
    const maxTranslateYPx = Math.max(0, (scaledPhotoHeight - 100) / 2) * 5.25;
    
    return {
      ...current,
      translateX: Math.max(-maxTranslateXPx, Math.min(maxTranslateXPx, current.translateX)),
      translateY: Math.max(-maxTranslateYPx, Math.min(maxTranslateYPx, current.translateY))
    };
  };

    // Handle photo pan (dengan edge-to-edge boundaries)
  const handlePhotoPan = (photoIndex, deltaX, deltaY) => {
    setPhotoTransforms(prev => {
      const current = prev[photoIndex] || { scale: 1, translateX: 0, translateY: 0, autoFillScale: 1 };
      const autoFillScale = current.autoFillScale || 1;
      const scale = current.scale;
      
      // Calculate exact boundaries berdasarkan foto dan slot dimensions
      const slot = frameConfig?.slots[photoIndex];
      if (!slot) return prev;
      
      // Foto dimensions setelah scale (assuming objectFit contain)
      const photoAspectRatio = 4 / 3; // Camera landscape
      const slotAspectRatio = slot.width / slot.height;
      
      // Calculate actual foto size dalam slot setelah objectFit contain + scale
      let photoWidthInSlot, photoHeightInSlot;
      
      if (photoAspectRatio > slotAspectRatio) {
        // Foto lebih landscape dari slot ‚Üí foto fit by width
        photoWidthInSlot = 100; // 100% slot width
        photoHeightInSlot = (100 / photoAspectRatio) * slotAspectRatio; // Proportional height
      } else {
        // Foto lebih portrait dari slot ‚Üí foto fit by height  
        photoHeightInSlot = 100; // 100% slot height
        photoWidthInSlot = (100 * photoAspectRatio) / slotAspectRatio; // Proportional width
      }
      
      // Apply scale to foto dimensions
      const scaledPhotoWidth = photoWidthInSlot * scale;
      const scaledPhotoHeight = photoHeightInSlot * scale;
      
      // Calculate maximum translate untuk edge-to-edge boundaries
      // Foto tidak boleh geser sampai ada gap antara foto edge dan slot edge
      const maxTranslateX = Math.max(0, (scaledPhotoWidth - 100) / 2); // Half of overflow
      const maxTranslateY = Math.max(0, (scaledPhotoHeight - 100) / 2); // Half of overflow
      
      // Convert percentage to pixels (approximate, untuk visual feedback)
      const maxTranslateXPx = maxTranslateX * 3.5; // Slot width ‚âà 350px * slot.width
      const maxTranslateYPx = maxTranslateY * 5.25; // Slot height ‚âà 525px * slot.height
      
      const newTranslateX = Math.max(-maxTranslateXPx, Math.min(maxTranslateXPx, current.translateX + deltaX));
      const newTranslateY = Math.max(-maxTranslateYPx, Math.min(maxTranslateYPx, current.translateY + deltaY));
      
      console.log(`üìç Photo ${photoIndex + 1}: Pan range ¬±${maxTranslateXPx.toFixed(0)}px√ó${maxTranslateYPx.toFixed(0)}px (scaled foto: ${scaledPhotoWidth.toFixed(0)}%√ó${scaledPhotoHeight.toFixed(0)}%)`);
      
      return {
        ...prev,
        [photoIndex]: {
          ...current,
          translateX: newTranslateX,
          translateY: newTranslateY
        }
      };
    });
  };

  // Reset photo transform (ke auto-fit optimal)
  const resetPhotoTransform = (photoIndex) => {
    const autoFillScale = calculateAutoFillScale(photoIndex);
    console.log(`üîÑ Reset Photo ${photoIndex + 1} to auto-fit: ${autoFillScale.toFixed(2)}x with centered position`);
    
    setPhotoTransforms(prev => ({
      ...prev,
      [photoIndex]: { 
        scale: autoFillScale, 
        translateX: 0, // Reset ke center
        translateY: 0, // Reset ke center
        autoFillScale: autoFillScale
      }
    }));
  };

  // Handle mouse down for pan
  const handlePhotoMouseDown = (e, photoIndex) => {
    if (selectedPhotoForEdit === photoIndex && e.button === 0) { // Left click only
      setIsDraggingPhoto(true);
      setDragStart({ x: e.clientX, y: e.clientY });
      e.preventDefault();
    }
  };

  // Handle mouse move for pan
  const handlePhotoMouseMove = (e, photoIndex) => {
    if (isDraggingPhoto && selectedPhotoForEdit === photoIndex) {
      const deltaX = e.clientX - dragStart.x;
      const deltaY = e.clientY - dragStart.y;
      
      handlePhotoPan(photoIndex, deltaX * 0.5, deltaY * 0.5); // Reduce sensitivity
      setDragStart({ x: e.clientX, y: e.clientY });
      e.preventDefault();
    }
  };

  // Handle mouse up for pan
  const handlePhotoMouseUp = () => {
    setIsDraggingPhoto(false);
  };

  // Debug: Calculate slot dimensions in pixels
  const calculateSlotPixels = (frameConfig, slotIndex) => {
    const FRAME_WIDTH = 350; // px
    const FRAME_HEIGHT = 525; // px
    
    const slot = frameConfig.slots[slotIndex];
    if (!slot) return null;
    
    return {
      left: Math.round(slot.left * FRAME_WIDTH),
      top: Math.round(slot.top * FRAME_HEIGHT),
      width: Math.round(slot.width * FRAME_WIDTH),
      height: Math.round(slot.height * FRAME_HEIGHT),
      aspectRatio: slot.aspectRatio,
      calculatedRatio: (slot.width * FRAME_WIDTH) / (slot.height * FRAME_HEIGHT)
    };
  };

  // Debug function untuk melihat state saat save
  const debugSaveState = () => {
    console.log('üîç DEBUG SAVE STATE:');
    console.log('üì∑ Photos:', photos);
    console.log('üñºÔ∏è Frame Config:', frameConfig);
    console.log('üéØ Selected Frame:', selectedFrame);
    console.log('üîß Photo Transforms:', photoTransforms);
    console.log('üñºÔ∏è Frame Image:', frameImage);
  };

  const handleSave = async () => {
    if (isSaving) return; // Prevent multiple saves
    
    debugSaveState(); // Debug current state
    console.log('üöÄ Starting save with Canvas API manual rendering...');
    
    setIsSaving(true);
    
    try {
      // Create canvas dengan dimensi yang tepat
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size to match preview (350x525) but with higher resolution
      const scale = 2; // 2x for better quality
      canvas.width = 350 * scale;
      canvas.height = 525 * scale;
      
      // Set background color (frame background)
      ctx.fillStyle = frameConfig?.layout?.backgroundColor || '#2563eb';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      console.log('ÔøΩ Canvas created:', canvas.width, 'x', canvas.height);
      
      // Function to load image as promise dengan CORS support
      const loadImage = (src) => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous'; // Enable CORS
          img.onload = () => {
            console.log('‚úÖ Image loaded successfully:', src.substring(0, 50) + '...');
            resolve(img);
          };
          img.onerror = (error) => {
            console.error('‚ùå Failed to load image:', error);
            reject(error);
          };
          img.src = src;
        });
      };
      
      // Load and draw photos first (behind frame)
      if (frameConfig && frameConfig.slots && photos.length > 0) {
        console.log('üì∏ Drawing photos to canvas...');
        
        for (let i = 0; i < Math.min(photos.length, frameConfig.slots.length); i++) {
          const photo = photos[i];
          const slot = frameConfig.slots[i];
          const transform = photoTransforms[i] || { scale: 1, translateX: 0, translateY: 0 };
          
          if (!photo) {
            console.warn(`‚ö†Ô∏è Skipping empty photo slot ${i + 1}`);
            continue;
          }
          
          try {
            const img = await loadImage(photo);
            
            // Calculate slot position and size in canvas coordinates
            const slotX = slot.left * canvas.width;
            const slotY = slot.top * canvas.height;
            const slotWidth = slot.width * canvas.width;
            const slotHeight = slot.height * canvas.height;
            
            console.log(`üì∏ Drawing photo ${i + 1} to slot:`, { slotX, slotY, slotWidth, slotHeight });
            
            // Save context untuk transformasi
            ctx.save();
            
            // Create clipping path untuk slot
            ctx.beginPath();
            ctx.rect(slotX, slotY, slotWidth, slotHeight);
            ctx.clip();
            
            // Calculate photo dimensions with aspect ratio preservation
            const photoAspect = img.width / img.height;
            const slotAspect = slotWidth / slotHeight;
            
            let drawWidth, drawHeight;
            if (photoAspect > slotAspect) {
              // Photo lebih wide, fit by height
              drawHeight = slotHeight * transform.scale;
              drawWidth = drawHeight * photoAspect;
            } else {
              // Photo lebih tall, fit by width
              drawWidth = slotWidth * transform.scale;
              drawHeight = drawWidth / photoAspect;
            }
            
            // Calculate position dengan transform (pan)
            const drawX = slotX + (slotWidth - drawWidth) / 2 + (transform.translateX * scale);
            const drawY = slotY + (slotHeight - drawHeight) / 2 + (transform.translateY * scale);
            
            // Draw photo
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            
            // Restore context
            ctx.restore();
            
            console.log(`‚úÖ Photo ${i + 1} drawn successfully`);
          } catch (error) {
            console.error(`‚ùå Failed to draw photo ${i + 1}:`, error);
          }
        }
      }
      
      // Load and draw frame on top
      if (frameImage) {
        console.log('ÔøΩÔ∏è Drawing frame overlay...');
        try {
          const frameImg = await loadImage(frameImage);
          
          // Draw frame covering entire canvas
          ctx.drawImage(frameImg, 0, 0, canvas.width, canvas.height);
          
          console.log('‚úÖ Frame drawn successfully');
        } catch (error) {
          console.error('‚ùå Failed to draw frame:', error);
        }
      }
      
      // Convert canvas to blob and download
      canvas.toBlob((blob) => {
        if (!blob) {
          console.error('‚ùå Failed to create blob from canvas');
          alert('Gagal membuat file. Silakan coba lagi.');
          setIsSaving(false);
          return;
        }
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `fremio-photo-${new Date().getTime()}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log('‚úÖ Photo saved successfully with Canvas API!');
        setIsSaving(false);
      }, 'image/png', 1.0);
      
    } catch (error) {
      console.error('‚ùå Canvas save failed:', error);
      alert('Gagal menyimpan foto. Silakan coba lagi.');
      setIsSaving(false);
    }
  };
            resolve({ img: null, index });
            return;
          }
          
          const img = new Image();
          img.onload = () => {
            console.log(`‚úÖ Photo ${index + 1}: Loaded (${img.width}x${img.height})`);
            resolve({ img, index });
          };
          img.onerror = (error) => {
            console.error(`‚ùå Photo ${index + 1}: Failed to load`, error);
            resolve({ img: null, index });
          };
          img.src = photoDataUrl;
        });
      });
      
      const loadedPhotos = await Promise.all(photoPromises);
      console.log('üì∏ Photos loaded:', loadedPhotos.filter(p => p.img).length, 'of', loadedPhotos.length);
      
      // Initialize rendered count
      let renderedCount = 0;
      
      // Render photos directly pada blue background (tanpa frame overlay yang menutupi)
      console.log('üñºÔ∏è Rendering photos directly on blue background...');
      for (const { img, index } of loadedPhotos) {
        if (!img) {
          console.warn(`‚ö†Ô∏è Skipping photo ${index + 1}: Failed to load`);
          continue;
        }
        
        if (!frameConfig.slots[index]) {
          console.warn(`‚ö†Ô∏è Skipping photo ${index + 1}: No slot config`);
          continue;
        }
        
        const slot = frameConfig.slots[index];
        const transform = photoTransforms[index] || { scale: 1, translateX: 0, translateY: 0 };
        
        // Calculate slot position dan size dalam canvas
        const slotX = (slot.left / 100) * canvasWidth;
        const slotY = (slot.top / 100) * canvasHeight;
        const slotWidth = (slot.width / 100) * canvasWidth;
        const slotHeight = (slot.height / 100) * canvasHeight;
        
        // Calculate foto position dengan transform
        const photoAspectRatio = 4 / 3; // Camera aspect ratio
        const slotAspectRatio = slot.width / slot.height;
        
        let photoWidth, photoHeight;
        
        // Auto-fit calculation (sama seperti di CSS)
        if (photoAspectRatio > slotAspectRatio) {
          // Foto landscape, fit by height
          photoHeight = slotHeight;
          photoWidth = photoHeight * photoAspectRatio;
        } else {
          // Foto portrait, fit by width  
          photoWidth = slotWidth;
          photoHeight = photoWidth / photoAspectRatio;
        }
        
        // Apply scale
        photoWidth *= transform.scale;
        photoHeight *= transform.scale;
        
        // Calculate center position
        const centerX = slotX + slotWidth / 2;
        const centerY = slotY + slotHeight / 2;
        
        // Apply translate - EXACT match dengan preview behavior
        // Preview container: 350px √ó 525px (2:3 ratio)
        // Canvas: 800px √ó 1200px (2:3 ratio)
        // Scale factor: 800/350 = 2.286 untuk X, 1200/525 = 2.286 untuk Y
        const previewToCanvasScale = canvasWidth / 350; // Should be same for both X and Y
        
        const translateXCanvas = transform.translateX * previewToCanvasScale;
        const translateYCanvas = transform.translateY * previewToCanvasScale;
        
        const photoX = centerX - photoWidth / 2 + translateXCanvas;
        const photoY = centerY - photoHeight / 2 + translateYCanvas;
        
        console.log(`üéØ Photo ${index + 1} FINAL render:`, { 
          slotX: slotX.toFixed(1), 
          slotY: slotY.toFixed(1), 
          slotWidth: slotWidth.toFixed(1), 
          slotHeight: slotHeight.toFixed(1),
          photoX: photoX.toFixed(1), 
          photoY: photoY.toFixed(1), 
          photoWidth: photoWidth.toFixed(1), 
          photoHeight: photoHeight.toFixed(1),
          transform: transform
        });
        
        // Debug: Draw a test rectangle to see if clipping area is correct
        ctx.save();
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Semi-transparent red
        ctx.fillRect(slotX, slotY, slotWidth, slotHeight);
        ctx.restore();
        
        // TEST: Draw foto WITHOUT clipping first to see if it appears
        console.log(`üß™ TEST: Drawing photo ${index + 1} WITHOUT clipping at (${photoX.toFixed(1)}, ${photoY.toFixed(1)})`);
        ctx.drawImage(img, photoX, photoY, photoWidth, photoHeight);
        
        // Then draw with clipping for final result
        ctx.save();
        ctx.beginPath();
        ctx.rect(slotX, slotY, slotWidth, slotHeight);
        ctx.clip();
        
        // Draw foto with clipping
        console.log(`üñºÔ∏è Drawing photo ${index + 1} WITH clipping`);
        ctx.drawImage(img, photoX, photoY, photoWidth, photoHeight);
        ctx.restore();
        
        renderedCount++;
        console.log(`‚úÖ Photo ${index + 1}: Rendered successfully on blue background`);
      }
      
      console.log(`üé® Final rendering complete: ${renderedCount} photos rendered on blue background`);
      
      // Debug: Draw canvas to screen untuk testing
      console.log('üîç Canvas final state - creating blob...');
      
      // Convert canvas ke blob dan trigger download
      canvas.toBlob((blob) => {
        if (!blob) {
          console.error('‚ùå Failed to generate blob from canvas');
          alert('Failed to generate image');
          return;
        }
        
        console.log('‚úÖ Blob created:', blob.size, 'bytes');
        
        // Create download link
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        
        // Generate filename dengan timestamp
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
        link.download = `photobooth-${selectedFrame}-${timestamp}.png`;
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Cleanup
        URL.revokeObjectURL(url);
        
        console.log('üíæ Photo saved successfully!');
        alert('Photo saved successfully!');
      }, 'image/png', 0.95);
      
    } catch (error) {
      console.error('‚ùå Save error:', error);
      alert('Failed to save photo. Please try again.');
    } finally {
      setIsSaving(false);
    }
  };

  const handlePrint = () => {
    // TODO: Implement print functionality
    alert('Print functionality will be implemented');
  };

  return (
    <div style={{
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f1eb 0%, #e8ddd4 100%)',
      padding: '2rem'
    }}>
      {/* Main Editor Layout */}
      <div style={{
        display: 'grid',
        gridTemplateColumns: '250px 1fr 250px',
        gap: '2rem',
        maxWidth: '1400px',
        margin: '0 auto'
      }}>
        
        {/* Left Panel - Toggle Tools */}
        <div style={{
          background: '#fff',
          borderRadius: '20px',
          padding: '1.5rem',
          height: 'fit-content'
        }}>
          <h3 style={{
            textAlign: 'center',
            marginBottom: '2rem',
            fontSize: '1.2rem',
            fontWeight: '600',
            color: '#333'
          }}>
            Toggle Tools
          </h3>
          
          <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: '1rem'
          }}>
            {/* Filter Toggle */}
            <button
              onClick={() => setActiveToggle('filter')}
              style={{
                background: activeToggle === 'filter' ? '#E8A889' : '#f8f9fa',
                color: activeToggle === 'filter' ? 'white' : '#333',
                border: 'none',
                borderRadius: '15px',
                padding: '1rem',
                fontSize: '1rem',
                fontWeight: '500',
                cursor: 'pointer',
                transition: 'all 0.3s ease',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '0.5rem'
              }}
            >
              <span style={{ fontSize: '1.5rem' }}>üì∑</span>
              Photos
            </button>
            
            {/* Adjust Toggle */}
            <button
              onClick={() => setActiveToggle('adjust')}
              style={{
                background: activeToggle === 'adjust' ? '#E8A889' : '#f8f9fa',
                color: activeToggle === 'adjust' ? 'white' : '#333',
                border: 'none',
                borderRadius: '15px',
                padding: '1rem',
                fontSize: '1rem',
                fontWeight: '500',
                cursor: 'pointer',
                transition: 'all 0.3s ease',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '0.5rem'
              }}
            >
              <span style={{ fontSize: '1.5rem' }}>‚öôÔ∏è</span>
              Adjust
            </button>
            
            {/* Frame Info */}
            {frameConfig && (
              <div style={{
                marginTop: '1rem',
                padding: '1rem',
                background: '#f8f9fa',
                borderRadius: '10px',
                fontSize: '0.85rem',
                color: '#666'
              }}>
                <div style={{ fontWeight: '600', marginBottom: '0.5rem' }}>
                  Current Frame:
                </div>
                <div>{frameConfig.name}</div>
                <div>{frameConfig.description}</div>
                <div style={{ marginTop: '0.5rem' }}>
                  Slots: {frameConfig.maxCaptures}
                </div>
              </div>
            )}

            {/* Debug Toggle */}
            <button
              onClick={() => setDebugMode(!debugMode)}
              style={{
                background: debugMode ? '#ff6b6b' : '#f8f9fa',
                color: debugMode ? '#fff' : '#666',
                border: 'none',
                borderRadius: '15px',
                padding: '1rem',
                fontSize: '1rem',
                fontWeight: '500',
                cursor: 'pointer',
                transition: 'all 0.3s ease',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '0.5rem'
              }}
            >
              <span style={{ fontSize: '1.5rem' }}>üîß</span>
              {debugMode ? 'Hide Debug' : 'Show Debug'}
            </button>
          </div>
        </div>

        {/* Center Panel - Preview */}
        <div style={{
          background: '#fff',
          borderRadius: '20px',
          padding: '2rem',
          textAlign: 'center'
        }}>
          <h3 style={{
            marginBottom: '2rem',
            fontSize: '1.4rem',
            fontWeight: '600',
            color: '#333'
          }}>
            Preview
          </h3>
          
          {/* Frame Preview Area */}
          <div style={{
            background: '#f8f9fa',
            borderRadius: '15px',
            padding: '3rem 2rem',
            marginBottom: '2rem',
            minHeight: '500px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            position: 'relative'
          }}>
            {frameConfig && frameImage ? (
              <div style={{
                position: 'relative',
                width: '350px',
                aspectRatio: '2/3',
                maxWidth: '100%',
                margin: '0 auto'
              }}>
                {/* Frame Image - RIGID, tidak berubah */}
                <img
                  src={frameImage}
                  alt={frameConfig.name}
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain',
                    zIndex: 10,
                    pointerEvents: 'none'
                  }}
                  draggable={false}
                />
                
                {/* Photo Slots - menyesuaikan dengan frame rigid */}
                {frameConfig.slots.map((slot, slotIndex) => (
                  <div
                    key={slot.id}
                    style={{
                      position: 'absolute',
                      left: `${slot.left * 100}%`,
                      top: `${slot.top * 100}%`,
                      width: `${slot.width * 100}%`,
                      height: `${slot.height * 100}%`,
                      zIndex: 5,
                      overflow: 'hidden',
                      backgroundColor: '#f8f9fa',
                      border: dragOverSlot === slotIndex ? '1px dashed #E8A889' : 'none',
                      transition: 'all 0.3s ease',
                      boxSizing: 'border-box',
                      // Pastikan aspect ratio 4:5 untuk slot
                      aspectRatio: slot.aspectRatio ? slot.aspectRatio.replace(':', '/') : '4/5'
                    }}
                    onDragOver={(e) => handleDragOver(e, slotIndex)}
                    onDragLeave={handleDragLeave}
                    onDrop={(e) => handleDrop(e, slotIndex)}
                  >
                    {photos[slotIndex] && (
                      <div style={{ 
                        position: 'relative', 
                        width: '100%', 
                        height: '100%',
                        overflow: 'hidden'
                      }}>
                        <img
                          src={photos[slotIndex]}
                          alt={`Photo ${slotIndex + 1}`}
                          style={{
                            ...calculatePhotoCropStyle(frameConfig, slotIndex),
                            opacity: draggedPhoto?.slotIndex === slotIndex ? 0.7 : 1,
                            cursor: selectedPhotoForEdit === slotIndex ? 'grab' : 'pointer'
                          }}
                          draggable={true}
                          onDragStart={(e) => handleDragStart(e, slotIndex, slotIndex)}
                          onClick={() => setSelectedPhotoForEdit(selectedPhotoForEdit === slotIndex ? null : slotIndex)}
                          onWheel={(e) => {
                            if (selectedPhotoForEdit === slotIndex) {
                              e.preventDefault();
                              const delta = e.deltaY > 0 ? -1 : 1;
                              handlePhotoZoom(slotIndex, delta);
                            }
                          }}
                          onMouseDown={(e) => handlePhotoMouseDown(e, slotIndex)}
                          onMouseMove={(e) => handlePhotoMouseMove(e, slotIndex)}
                          onMouseUp={handlePhotoMouseUp}
                          onMouseLeave={handlePhotoMouseUp}
                        />
                        
                        {/* Photo Edit Controls */}
                        {selectedPhotoForEdit === slotIndex && (
                          <div style={{
                            position: 'absolute',
                            bottom: '4px',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            display: 'flex',
                            gap: '4px',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            borderRadius: '20px',
                            padding: '4px 8px',
                            zIndex: 20
                          }}>
                            {/* Zoom Out */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handlePhotoZoom(slotIndex, -1);
                              }}
                              style={{
                                background: 'none',
                                border: 'none',
                                color: 'white',
                                fontSize: '14px',
                                cursor: 'pointer',
                                padding: '2px 4px'
                              }}
                            >
                              üîç-
                            </button>
                            
                            {/* Zoom In */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handlePhotoZoom(slotIndex, 1);
                              }}
                              style={{
                                background: 'none',
                                border: 'none',
                                color: 'white',
                                fontSize: '14px',
                                cursor: 'pointer',
                                padding: '2px 4px'
                              }}
                            >
                              üîç+
                            </button>
                            
                            {/* Zoom Level Indicator */}
                            <span style={{
                              color: 'white',
                              fontSize: '10px',
                              padding: '2px 4px',
                              backgroundColor: 'rgba(255, 255, 255, 0.2)',
                              borderRadius: '4px',
                              minWidth: '30px',
                              textAlign: 'center'
                            }}>
                              {(photoTransforms[slotIndex]?.scale || 1).toFixed(1)}x
                            </span>
                            
                            {/* Reset */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                resetPhotoTransform(slotIndex);
                              }}
                              style={{
                                background: 'none',
                                border: 'none',
                                color: 'white',
                                fontSize: '12px',
                                cursor: 'pointer',
                                padding: '2px 4px'
                              }}
                            >
                              ‚Ü∫
                            </button>
                          </div>
                        )}
                        
                        {/* Photo Selection Indicator */}
                        {selectedPhotoForEdit === slotIndex && (
                          <div style={{
                            position: 'absolute',
                            top: '2px',
                            right: '2px',
                            backgroundColor: '#00ff00',
                            color: 'black',
                            fontSize: '10px',
                            padding: '2px 6px',
                            borderRadius: '10px',
                            fontWeight: 'bold',
                            zIndex: 20
                          }}>
                            EDIT
                          </div>
                        )}
                      </div>
                    )}
                    {!photos[slotIndex] && (
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        height: '100%',
                        color: '#9ca3af',
                        fontSize: '0.7rem',
                        textAlign: 'center',
                        fontWeight: '500'
                      }}>
                        Slot {slotIndex + 1}
                      </div>
                    )}
                  </div>
                ))}
                
                {/* Frame Info */}
                <div style={{
                  position: 'absolute',
                  bottom: '-40px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  fontSize: '0.8rem',
                  color: '#666',
                  textAlign: 'center',
                  whiteSpace: 'nowrap',
                  background: 'rgba(255,255,255,0.9)',
                  padding: '4px 8px',
                  borderRadius: '6px',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                }}>
                  {frameConfig.name} | {photos.filter(p => p).length}/{frameConfig.maxCaptures} photos
                </div>

                {/* Debug Overlay */}
                {debugMode && frameConfig.slots.map((slot, slotIndex) => {
                  const pixels = calculateSlotPixels(frameConfig, slotIndex);
                  return (
                    <div
                      key={`debug_${slot.id}`}
                      style={{
                        position: 'absolute',
                        left: `${slot.left * 100}%`,
                        top: `${slot.top * 100}%`,
                        width: `${slot.width * 100}%`,
                        height: `${slot.height * 100}%`,
                        border: '2px dashed #ff0000',
                        background: 'rgba(255, 0, 0, 0.1)',
                        zIndex: 15,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        fontSize: '10px',
                        fontWeight: 'bold',
                        color: '#ff0000',
                        textAlign: 'center',
                        pointerEvents: 'none',
                        boxSizing: 'border-box'
                      }}
                    >
                      {slot.id}<br/>
                      {pixels.width}x{pixels.height}px<br/>
                      AR: {pixels.calculatedRatio.toFixed(2)}
                    </div>
                  );
                })}
              </div>
            ) : (
              <div style={{
                color: '#666',
                fontSize: '1.1rem',
                textAlign: 'center'
              }}>
                {frameConfig ? 'Loading frame...' : 'No frame selected'}
              </div>
            )}
          </div>

          {/* Save and Print Buttons */}
          <div style={{
            display: 'flex',
            gap: '1rem',
            justifyContent: 'center',
            flexDirection: 'column',
            alignItems: 'center'
          }}>
            {/* Debug Button */}
            <button
              onClick={debugSaveState}
              style={{
                background: '#f0f0f0',
                border: '1px solid #ccc',
                color: '#666',
                borderRadius: '15px',
                padding: '0.5rem 1rem',
                fontSize: '0.8rem',
                cursor: 'pointer'
              }}
            >
              üîç Debug Save Data
            </button>
            
            <div style={{
              display: 'flex',
              gap: '1rem',
              justifyContent: 'center'
            }}>
            <button
              onClick={handleSave}
              disabled={isSaving}
              style={{
                background: isSaving ? '#f5f5f5' : '#fff',
                border: '2px solid #E8A889',
                color: isSaving ? '#999' : '#E8A889',
                borderRadius: '25px',
                padding: '0.8rem 2rem',
                fontSize: '1rem',
                fontWeight: '600',
                cursor: isSaving ? 'not-allowed' : 'pointer',
                transition: 'all 0.3s ease',
                opacity: isSaving ? 0.7 : 1
              }}
              onMouseEnter={(e) => {
                if (!isSaving) {
                  e.target.style.background = '#E8A889';
                  e.target.style.color = 'white';
                }
              }}
              onMouseLeave={(e) => {
                if (!isSaving) {
                  e.target.style.background = '#fff';
                  e.target.style.color = '#E8A889';
                }
              }}
            >
              {isSaving ? 'üíæ Saving...' : 'Save'}
            </button>
            <button
              onClick={handlePrint}
              style={{
                background: '#E8A889',
                border: 'none',
                color: 'white',
                borderRadius: '25px',
                padding: '0.8rem 2rem',
                fontSize: '1rem',
                fontWeight: '600',
                cursor: 'pointer',
                transition: 'all 0.3s ease'
              }}
              onMouseEnter={(e) => {
                e.target.style.background = '#d49673';
              }}
              onMouseLeave={(e) => {
                e.target.style.background = '#E8A889';
              }}
            >
              Print
            </button>
            </div>
          </div>
        </div>

        {/* Right Panel - Filter or Adjust */}
        <div style={{
          background: '#fff',
          borderRadius: '20px',
          padding: '1.5rem',
          height: 'fit-content'
        }}>
          <h3 style={{
            textAlign: 'center',
            marginBottom: '2rem',
            fontSize: '1.2rem',
            fontWeight: '600',
            color: '#333'
          }}>
            {debugMode ? 'Debug Info' : (activeToggle === 'filter' ? 'All Photos' : 'Adjust Settings')}
          </h3>
          
          {debugMode ? (
            /* Debug Panel */
            frameConfig && (
              <div>
                <div style={{ 
                  display: 'flex', 
                  justifyContent: 'space-between', 
                  alignItems: 'center',
                  marginBottom: '1rem', 
                  fontSize: '0.9rem' 
                }}>
                  <div>
                    <strong>Frame:</strong> {frameConfig.name}<br/>
                    <strong>Max Captures:</strong> {frameConfig.maxCaptures}<br/>
                    <strong>Layout Ratio:</strong> {frameConfig.layout.aspectRatio}
                  </div>
                  <button
                    onClick={reloadFrameConfig}
                    disabled={isReloading}
                    style={{
                      padding: '6px 12px',
                      fontSize: '11px',
                      backgroundColor: isReloading ? '#6c757d' : '#28a745',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: isReloading ? 'not-allowed' : 'pointer',
                      fontWeight: 'bold',
                      opacity: isReloading ? 0.7 : 1
                    }}
                  >
                    {isReloading ? '‚è≥ Loading...' : 'üîÑ Reload Config'}
                  </button>
                </div>
                
                <table 
                  key={`debug-table-${configReloadKey}`}
                  style={{ width: '100%', borderCollapse: 'collapse', fontSize: '11px' }}
                >
                  <thead>
                    <tr style={{ background: '#f0f0f0' }}>
                      <th style={{ border: '1px solid #ddd', padding: '6px' }}>Slot</th>
                      <th style={{ border: '1px solid #ddd', padding: '6px' }}>Position (%)</th>
                      <th style={{ border: '1px solid #ddd', padding: '6px' }}>Size (px)</th>
                      <th style={{ border: '1px solid #ddd', padding: '6px' }}>Ratio</th>
                    </tr>
                  </thead>
                  <tbody>
                    {frameConfig.slots.map((slot, index) => {
                      const pixels = calculateSlotPixels(frameConfig, index);
                      const isRatioCorrect = Math.abs(pixels.calculatedRatio - 0.8) < 0.01;
                      return (
                        <tr key={slot.id}>
                          <td style={{ border: '1px solid #ddd', padding: '6px' }}>{slot.id}</td>
                          <td style={{ border: '1px solid #ddd', padding: '6px' }}>
                            L:{(slot.left * 100).toFixed(0)}% T:{(slot.top * 100).toFixed(0)}%<br/>
                            W:{(slot.width * 100).toFixed(0)}% H:{(slot.height * 100).toFixed(0)}%
                          </td>
                          <td style={{ border: '1px solid #ddd', padding: '6px' }}>
                            {pixels.width}√ó{pixels.height}px
                          </td>
                          <td style={{ border: '1px solid #ddd', padding: '6px' }}>
                            {pixels.calculatedRatio.toFixed(2)}<br/>
                            {!isRatioCorrect && <span style={{ color: 'red' }}>‚ö†Ô∏è</span>}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>

                <div style={{ 
                  marginTop: '1rem', 
                  padding: '0.8rem', 
                  background: '#f8f9fa', 
                  borderRadius: '8px', 
                  fontSize: '0.8rem' 
                }}>
                  <strong>Instructions:</strong><br/>
                  ‚Ä¢ Red boxes show slot positions<br/>
                  ‚Ä¢ Aspect ratio should be 0.80 for 4:5<br/>
                  ‚Ä¢ Adjust coordinates in frameConfigs.js
                </div>
              </div>
            )
          ) : activeToggle === 'filter' ? (
            <div style={{
              display: 'flex',
              flexDirection: 'column',
              gap: '1rem'
            }}>
              <div style={{
                fontSize: '0.9rem',
                color: '#666',
                textAlign: 'center',
                marginBottom: '1rem'
              }}>
                {selectedPhotoForEdit !== null 
                  ? `‚ú® Adjusting Photo ${selectedPhotoForEdit + 1} - Smart boundaries ensure slot coverage` 
                  : 'Auto-fit preserves vertical height, Smart limits prevent empty slots'
                }
              </div>
              
              {/* All Photos Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(2, 1fr)',
                gap: '0.5rem'
              }}>
                {photos.map((photo, index) => (
                  <div
                    key={index}
                    style={{
                      borderRadius: '8px',
                      overflow: 'hidden',
                      border: selectedPhoto === index ? '2px solid #E8A889' : '1px solid #e5e7eb',
                      cursor: 'pointer',
                      transition: 'all 0.3s ease',
                      aspectRatio: '4/5', // Konsisten dengan rasio frame slot
                      backgroundColor: '#f8f9fa'
                    }}
                    onClick={() => setSelectedPhoto(index)}
                  >
                    <img
                      src={photo}
                      alt={`Photo ${index + 1}`}
                      style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                        objectPosition: 'center center'
                      }}
                    />
                  </div>
                ))}
              </div>
              
              {photos.length === 0 && (
                <div style={{
                  color: '#666',
                  fontSize: '0.9rem',
                  textAlign: 'center',
                  padding: '2rem'
                }}>
                  No photos available. Take some photos first!
                </div>
              )}
            </div>
          ) : (
            <div style={{
              display: 'flex',
              flexDirection: 'column',
              gap: '1rem'
            }}>
              <div style={{
                color: '#666',
                fontSize: '0.9rem',
                textAlign: 'center',
                padding: '2rem'
              }}>
                Adjustment controls will be displayed here
              </div>
              {/* TODO: Add adjustment controls */}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}